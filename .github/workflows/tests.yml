name: Test example applications

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  # Cancel previous running actions for the same PR
  cancel_previous:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      - name: Cancel Workflow Action
        uses: styfle/cancel-workflow-action@0.11.0

  checks:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      # --- Update code ---
      - name: "Checkout code"
        uses: actions/checkout@v4
        with:
          submodules: true
      # --- Formatting ---
      - name: "Format code"
        run: ./bin/inv_wrapper.sh format-code --check

  # Work-out whether we need to re-build the examples. We need to re-build the
  # examples if either _any_ fo the examples has changed, or the WASM cache
  # has expired
  needs-build:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    outputs:
      needs-wasm: ${{ (steps.filter.outputs.examples-changed == 'true') || (steps.wasm-cache.outputs.cache-hit != 'true') }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
      # Check if any of the submodules have been modified
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            examples-changed:
              - './examples/**'
      # Check if we have a WASM cache hit
      - name: "Get CPP/Python commits"
        id: submodule-commit
        run: |
          git submodule update --init ./cpp
          git submodule update --init ./python
          sudo apt install -y zstd
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          echo "cpp-commit=$(git submodule status ./cpp | cut '-d ' -f 2)" >> $GITHUB_OUTPUT
          echo "py-commit=$(git submodule status ./python | cut '-d ' -f 2)" >> $GITHUB_OUTPUT
      - uses: actions/cache/restore@v3.3.1
        id: wasm-cache
        with:
          path: ./wasm
          key: wasm-${{ steps.submodule-commit.outputs.cpp-commit }}-${{ steps.submodule-commit.outputs.py-commit }}
          lookup-only: true

  build-examples:
    needs: needs-build
    if: ${{ needs.needs-build.outputs.needs-wasm == 'true' }}
    runs-on: ubuntu-latest
    container:
      image: faasm.azurecr.io/examples-build:0.3.1_0.3.1
      credentials:
        username: ${{ secrets.ACR_SERVICE_PRINCIPAL_ID }}
        password: ${{ secrets.ACR_SERVICE_PRINCIPAL_PASSWORD }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v4
        with:
          submodules: true
      - name: "Build FFmpeg"
        run: ./bin/inv_wrapper.sh ffmpeg
      - name: "Build ImageMagick"
        run: ./bin/inv_wrapper.sh libpng imagemagick
      - name: "Build Kernels"
        run: ./bin/inv_wrapper.sh kernels kernels --native
      - name: "Build LAMMPS"
        run: ./bin/inv_wrapper.sh lammps lammps --native
      - name: "Build LAMMPS with migration"
        run: ./bin/inv_wrapper.sh lammps --migration lammps --native --migration
      - name: "Build LAMMPS with migration and network phase"
        run: ./bin/inv_wrapper.sh lammps --migration-net lammps --native --migration-net
      - name: "Build Lulesh"
        run: ./bin/inv_wrapper.sh lulesh lulesh --native
      - name: "Build TensorFlow"
        run: ./bin/inv_wrapper.sh tensorflow
      - name: "Build PolyBench/C"
        run: ./bin/inv_wrapper.sh polybench polybench --native
      - name: "Build functions used in the tests"
        run: ./bin/inv_wrapper.sh func.tests
      - name: "Get CPP/Python commits"
        id: submodule-commit
        run: |
          apt install -y zstd
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          echo "cpp-commit=$(git submodule status ./cpp | cut '-d ' -f 2)" >> $GITHUB_OUTPUT
          echo "py-commit=$(git submodule status ./python | cut '-d ' -f 2)" >> $GITHUB_OUTPUT
          # Also move to a different path to restore from
          mv /usr/local/faasm/wasm ./wasm
      # If we are here we _always_ want to overwrite the cache
      - name: "Prepare WASM cache"
        uses: actions/cache/save@v3.3.1
        if: always()
        with:
          path: ./wasm
          key: wasm-${{ steps.submodule-commit.outputs.cpp-commit }}-${{ steps.submodule-commit.outputs.py-commit }}

  run-examples-faasmctl:
    needs: [build-examples]
    if:
      always() &&
      !cancelled() &&
      github.event.pull_request.draft == false &&
      (needs.build-examples.result == 'success' || needs.build-examples.result == 'skipped')
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        faasm_wasm_vm: [wavm, wamr]
    defaults:
      run:
        shell: bash
    env:
      CONAN_CACHE_MOUNT_SOURCE: ~/.conan
      FAASM_INI_FILE: ./faasm.ini
      FAASM_VERSION: 0.20.1
      FAASM_WASM_VM: ${{ matrix.faasm_wasm_vm }}
    steps:
      - uses: csegarragonz/set-compose-version-action@main
        with:
          compose-version: "2.22.0"
      # A regular `faasmctl` deployment pulls a lot of docker images, so we
      # may run out of disk space
      - name: "Maximize build space"
        uses: easimon/maximize-build-space@master
        with:
          # Leave 25 GB for the / partition for docker images (stored under
          # /var/lib/docker)
          root-reserve-mb: 25600
          remove-android: 'true'
          remove-codeql: 'true'
          remove-docker-images: 'true'
          remove-dotnet: 'true'
          remove-haskell: 'true'
      - name: "Checkout code"
        uses: actions/checkout@v4
      - name: "Install faasmctl"
        run: pip3 install $(cat ./requirements.txt | grep faasmctl | tr -d '\n')
      - name: "Start a Faasm cluster to run the examples"
        run: faasmctl deploy.compose --workers=2
      # This can fail when the container isn't ready, so we want to retry
      - name: "Wait for upload server to be available"
        run: |
          (echo "Attempt 1" && faasmctl cli.faasm --cmd "./deploy/local/wait_for_upload.sh upload 8002") || \
          (echo "Attempt 2" && faasmctl cli.faasm --cmd "./deploy/local/wait_for_upload.sh upload 8002") || \
          (echo "Attempt 3" && faasmctl cli.faasm --cmd "./deploy/local/wait_for_upload.sh upload 8002") || \
          (echo "Wait for upload failed after retries" && faasmctl logs -s upload && exit 1)
      - name: "Get CPP/Python commits"
        id: submodule-commit
        run: |
          sudo apt install -y zstd
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git submodule update --init ./cpp
          git submodule update --init ./python
          echo "cpp-commit=$(git submodule status ./cpp | cut '-d ' -f 2)" >> $GITHUB_OUTPUT
          echo "py-commit=$(git submodule status ./python | cut '-d ' -f 2)" >> $GITHUB_OUTPUT
      - name: "Get WASM cache"
        uses: actions/cache/restore@v3.3.1
        id: cpp-wasm-cache
        with:
          path: ./wasm
          key: wasm-${{ steps.submodule-commit.outputs.cpp-commit }}-${{ steps.submodule-commit.outputs.py-commit }}
          fail-on-cache-miss: true
      - name: "Upload all WASM files to the cluster"
        run: ./bin/inv_wrapper.sh wasm.upload
      - name: "Run MPI kernels"
        # TODO: MPI kernels still not run in WAMR because there's a seg. fault
        # with the `exit` syscall
        if: "contains(env.FAASM_WASM_VM, 'wavm')"
        timeout-minutes: 2
        run: |
          # The global MPI kernel stopped working when enabling SIMD
          # faasmctl invoke kernels-mpi global --cmdline '10 1024'
          faasmctl invoke kernels-mpi p2p --cmdline '10 1024 1024' --mpi-world-size 4
          faasmctl invoke kernels-mpi sparse --cmdline '10 10 5' --mpi-world-size 4
          faasmctl invoke kernels-mpi transpose --cmdline '10 1024 32' --mpi-world-size 4
          faasmctl invoke kernels-mpi stencil --cmdline '10 1000' --mpi-world-size 4
          # The dgemm MPI kernel does not work because we are missing
          # implementations for MPI_Comm_group, MPI_Group_incl, and MPI_Comm_create
          # faasmctl invoke kernels-mpi dgemm --cmdline '10 1024 32 1' --mpi-world-size 4
          faasmctl invoke kernels-mpi nstream --cmdline '10 1024 32' --mpi-world-size 4
          faasmctl invoke kernels-mpi reduce --cmdline '10 1024' --mpi-world-size 4
          # The random MPI kernel does not work because we are missing
          # implementations for MPI_Alltoallv
          # faasmctl invoke kernels-mpi random --cmdline '32 20' --mpi-world-size 4
      - name: "Run OpenMP kernels"
        if: "contains(env.FAASM_WASM_VM, 'wavm')"
        timeout-minutes: 2
        run: |
          faasmctl invoke kernels-omp global --cmdline '2 10 1024'
          faasmctl invoke kernels-omp p2p --cmdline '2 10 1024 1024'
          # The sparse OpenMP kernel fails during the result integrity checks
          # faasmctl invoke kernels-omp sparse --cmdline '2 10 10 5'
          # The transpose OpenMP kernel can not be cross-compiled due to problems
          # with the static_for signature and symbol definition
          # faasmctl invoke kernels-omp transpose --cmdline '10 1024 32'
          # The stencil OpenMP kernel can not be cross-compiled due to a problem
          # with the faasm_sm_reduce signature
          # faasmctl invoke kernels-omp stencil --cmdline '10 1000'
          faasmctl invoke kernels-omp dgemm --cmdline '2 2 1024 32'
          faasmctl invoke kernels-omp nstream --cmdline '2 10 1024 32'
          faasmctl invoke kernels-omp reduce --cmdline '2 10 1024'
          # The random OpenMP kernel can not be cross-compiled due to a problem
          # with the faasm_sm_reduce signature
          # faasmctl invoke kernels-omp random --cmdline '32 20'
      - name: "Run PolyBench/C"
        timeout-minutes: 2
        # We deliberately enumerate all the supported functions here and
        # execute them individually, rather than using the microbench runner.
        # This is so that we can more easily track what functions are supported
        # and what functions are not
        run: |
          faasmctl invoke polybench poly_covariance
          faasmctl invoke polybench poly_correlation
          faasmctl invoke polybench poly_2mm
          faasmctl invoke polybench poly_3mm
          faasmctl invoke polybench poly_atax
          faasmctl invoke polybench poly_bicg
          faasmctl invoke polybench poly_doitgen
          faasmctl invoke polybench poly_mvt
          faasmctl invoke polybench poly_cholesky
          faasmctl invoke polybench poly_durbin
          faasmctl invoke polybench poly_gramschmidt
          faasmctl invoke polybench poly_lu
          faasmctl invoke polybench poly_ludcmp
          faasmctl invoke polybench poly_trisolv
          faasmctl invoke polybench poly_deriche
          faasmctl invoke polybench poly_floyd-warshall
          faasmctl invoke polybench poly_nussinov
          faasmctl invoke polybench poly_adi
          faasmctl invoke polybench poly_fdtd-2d
          faasmctl invoke polybench poly_heat-3d
          faasmctl invoke polybench poly_jacobi-1d
          faasmctl invoke polybench poly_jacobi-2d
          faasmctl invoke polybench poly_seidel-2d
      - name: "Run ImageMagick"
        if: "contains(env.FAASM_WASM_VM, 'wavm')"
        timeout-minutes: 1
        run: faasmctl invoke imagemagick main --cmdline 'faasm://im/sample_image.png -flip faasm://im/image_out.png'
      - name: "Run LAMMPS"
        timeout-minutes: 1
        run: faasmctl invoke lammps main --cmdline '-in faasm://lammps-data/in.controller.wall' --mpi-world-size 4
      # Note that the migration experiment does not migrate, it just checks the binary
      - name: "Run LAMMPS migration binary"
        timeout-minutes: 1
        run: faasmctl invoke lammps migration --cmdline '-in faasm://lammps-data/in.controller.wall' --mpi-world-size 4 --input-data '1 2'
      - name: "Run LAMMPS migration-net binary"
        timeout-minutes: 1
        run: faasmctl invoke lammps migration-net --cmdline '-in faasm://lammps-data/in.controller.wall' --mpi-world-size 4 --input-data '1 2 10 2'
          # 08/12/2023 - LULESH is broken with a memory leak
          #       - name: "Run LULESH"
          #         timeout-minutes: 1
          #         if: "contains(env.FAASM_WASM_VM, 'wavm')"
          #         run: faasmctl invoke lulesh main --cmdline '-i 5 -s 20 -r 11 -c 1 -b 1' --input-data '4'
      - name: "Run TFlite check"
        timeout-minutes: 1
        if: "contains(env.FAASM_WASM_VM, 'wavm')"
        run: faasmctl invoke tf check
      - name: "Run FFmpeg check"
        timeout-minutes: 1
        run: faasmctl invoke ffmpeg check
